     ylab=expression(paste("No. of grid points (", italic(N), ")")),
     main=paste("No. of grid points required to keep the error below ", eps)) 
dom <- c(0,1)
yylim <- c(0,2)
grid <- seq(from=dom[1], to=dom[2], by=0.01)
f <- function(x) {0.7 + (cos(5*x) + sin(2*x))^2}
op <- par(mfrow=c(2,1))
plot(grid, f(grid), type="l", col="black", main="Trapezoidal rule", )
c <- 2
eps <- 0.01
d <- seq(from=1, to=5, by=1) # dimension of the domain
gridpoints <- round(exp(-d/c*log(eps)))
options(scipen=5)
plot(d, gridpoints, type="b", xlab=expression(paste("Dimension (", italic(d), ")")), 
     ylab=expression(paste("No. of grid points (", italic(N), ")")),
     main=paste("No. of grid points required to keep the error below ", eps)) 
dom <- c(0,1)
yylim <- c(0,2)
grid <- seq(from=dom[1], to=dom[2], by=0.01)
f <- function(x) {0.7 + (cos(5*x) + sin(2*x))^2}
op <- par(mfrow=c(2,1))
plot(grid, f(grid), type="l", col="black", main="Trapezoidal rule", ylim=yylim)
c <- 2
eps <- 0.01
d <- seq(from=1, to=5, by=1) # dimension of the domain
gridpoints <- round(exp(-d/c*log(eps)))
options(scipen=5)
plot(d, gridpoints, type="b", xlab=expression(paste("Dimension (", italic(d), ")")), 
     ylab=expression(paste("No. of grid points (", italic(N), ")")),
     main=paste("No. of grid points required to keep the error below ", eps)) 
verydarkgrey <- rgb(0.5, 0.5, 0.5)
## EXAMPLE 1
## Numerical integration methods: illustration of the curse of dimensionality 
dom <- c(0,1)
yylim <- c(0,2)
grid <- seq(from=dom[1], to=dom[2], by=0.01)
f <- function(x) {0.7 + (cos(5*x) + sin(2*x))^2}
op <- par(mfrow=c(2,1))
plot(grid, f(grid), type="l", col="black", 
  main=expression(paste("Trapezoidal rule for ", italic(d), "=1"),
  ylim=yylim,
  xlab=expression(italic(x)), ylab=expression(paste(italic(f), group("(", italic(x),")"))))
c <- 2
eps <- 0.01
d <- seq(from=1, to=5, by=1) # dimension of the domain
gridpoints <- round(exp(-d/c*log(eps)))
options(scipen=5)
plot(d, gridpoints, type="b", xlab=expression(paste("Dimension (", italic(d), ")")), 
     ylab=expression(paste("No. of grid points (", italic(N), ")")),
     main=paste("No. of grid points required to keep the error below ", eps)) 
## EXAMPLE 1
## Numerical integration methods: illustration of the curse of dimensionality 
dom <- c(0,1)
yylim <- c(0,2)
grid <- seq(from=dom[1], to=dom[2], by=0.01)
f <- function(x) {0.7 + (cos(5*x) + sin(2*x))^2}
op <- par(mfrow=c(2,1))
plot(grid, f(grid), type="l", col="black", 
  main=expression(paste("Trapezoidal rule for ", italic(d), "=1")),
  ylim=yylim,
  xlab=expression(italic(x)), ylab=expression(paste(italic(f), group("(", italic(x),")"))))
c <- 2
eps <- 0.01
d <- seq(from=1, to=5, by=1) # dimension of the domain
gridpoints <- round(exp(-d/c*log(eps)))
options(scipen=5)
plot(d, gridpoints, type="b", xlab=expression(paste("Dimension (", italic(d), ")")), 
     ylab=expression(paste("No. of grid points (", italic(N), ")")),
     main=paste("No. of grid points required to keep the error below ", eps)) 
dom <- c(0,1)
yylim <- c(0,2)
grid <- seq(from=dom[1], to=dom[2], by=0.01)
f <- function(x) {0.4 + (cos(5*x) + sin(2*x))^2}
op <- par(mfrow=c(2,1))
plot(grid, f(grid), type="l", col="black", 
  main=expression(paste("Trapezoidal rule for ", italic(d), "=1")),
  ylim=yylim,
  xlab=expression(italic(x)), ylab=expression(paste(italic(f), group("(", italic(x),")"))))
c <- 2
eps <- 0.01
d <- seq(from=1, to=5, by=1) # dimension of the domain
gridpoints <- round(exp(-d/c*log(eps)))
options(scipen=5)
plot(d, gridpoints, type="b", xlab=expression(paste("Dimension (", italic(d), ")")), 
     ylab=expression(paste("No. of grid points (", italic(N), ")")),
     main=paste("No. of grid points required to keep the error below ", eps)) 
?legend
qdom <- c(0,1)
yylim <- c(0,2)
grid <- seq(from=dom[1], to=dom[2], by=0.01)
f <- function(x) {0.4 + (cos(5*x) + sin(2*x))^2}
op <- par(mfrow=c(2,1))
plot(grid, f(grid), type="l", col="black", 
  main=expression(paste("Trapezoidal rule for ", italic(d), "=1")),
  ylim=yylim,
  xlab=expression(italic(x)), ylab=expression(paste(italic(f), group("(", italic(x),")"))))
legend("topleft", legend=c(expression(italic(f))), lty=c(1)) 
c <- 2
eps <- 0.01
d <- seq(from=1, to=5, by=1) # dimension of the domain
gridpoints <- round(exp(-d/c*log(eps)))
options(scipen=5)
plot(d, gridpoints, type="b", xlab=expression(paste("Dimension (", italic(d), ")")), 
     ylab=expression(paste("No. of grid points (", italic(N), ")")),
     main=paste("No. of grid points required to keep the error below ", eps)) 
dom <- c(0,1)
yylim <- c(0,2)
grid <- seq(from=dom[1], to=dom[2], by=0.01)
f <- function(x) {0.4 + (cos(5*x) + sin(2*x))^2}
op <- par(mfrow=c(2,1))
plot(grid, f(grid), type="l", col="black", 
  main=expression(paste("Trapezoidal rule for ", italic(d), "=1")),
  ylim=yylim,
  xlab=expression(italic(x)), ylab=expression(paste(italic(f), group("(", italic(x),")"))))
legend("topleft", legend=c(expression(italic(f))), lty=c(1), bty='n') 
c <- 2
eps <- 0.01
d <- seq(from=1, to=5, by=1) # dimension of the domain
gridpoints <- round(exp(-d/c*log(eps)))
options(scipen=5)
plot(d, gridpoints, type="b", xlab=expression(paste("Dimension (", italic(d), ")")), 
     ylab=expression(paste("No. of grid points (", italic(N), ")")),
     main=paste("No. of grid points required to keep the error below ", eps)) 
verydarkgrey <- rgb(0.5, 0.5, 0.5)
## EXAMPLE 1
## Numerical integration methods: illustration of the curse of dimensionality 
dom <- c(0,1)
yylim <- c(0,2)
grid <- seq(from=dom[1], to=dom[2], by=0.01)
f <- function(x) {0.4 + (cos(5*x) + sin(2*x))^2}
op <- par(mfrow=c(2,1))
plot(grid, f(grid), type="l", col="black", 
  main=expression(paste(bold("Trapezoidal rule for "), italic(d), "=1")),
  ylim=yylim,
  xlab=expression(italic(x)), ylab=expression(paste(italic(f), group("(", italic(x),")"))))
legend("topleft", legend=c(expression(italic(f))), lty=c(1), bty='n') 
c <- 2
eps <- 0.01
d <- seq(from=1, to=5, by=1) # dimension of the domain
gridpoints <- round(exp(-d/c*log(eps)))
options(scipen=5)
plot(d, gridpoints, type="b", xlab=expression(paste("Dimension (", italic(d), ")")), 
     ylab=expression(paste("No. of grid points (", italic(N), ")")),
     main=paste("No. of grid points required to keep the error below ", eps)) 
verydarkgrey <- rgb(0.5, 0.5, 0.5)
## EXAMPLE 1
## Numerical integration methods: illustration of the curse of dimensionality 
dom <- c(0,1)
yylim <- c(0,2)
grid <- seq(from=dom[1], to=dom[2], by=0.01)
f <- function(x) {0.4 + (cos(5*x) + sin(2*x))^2}
op <- par(mfrow=c(2,1))
plot(grid, f(grid), type="l", col="black", 
  main=expression(paste(bold("Trapezoidal rule for "), italic(d), "=1")),
  ylim=yylim,
  xlab=expression(italic(x)), ylab=expression(paste(italic(f), group("(", italic(x),")"))))
legend("topleft", legend=c(expression(italic(f))), lty=c(1), bty='n') 
c <- 2
eps <- 0.01
d <- seq(from=1, to=5, by=1) # dimension of the domain
gridpoints <- round(exp(-d/c*log(eps)))
options(scipen=5)
plot(d, gridpoints, type="b", xlab=expression(paste("Dimension (", italic(d), ")")), 
     ylab=expression(paste("No. of grid points (", italic(N), ")")),
     main="Curse of dimensionality")
delta <- diff(dom)/N
dom <- c(0,1)
yylim <- c(0,2)
grid <- seq(from=dom[1], to=dom[2], by=0.01)
N <- 10 # number of grid points for the trapezoidal rule
NN <- seq(from=dom[1], to=dom[2], length=N+1)
delta <- diff(dom)/N
f <- function(x) {0.4 + (cos(5*x) + sin(2*x))^2}
op <- par(mfrow=c(2,1))
delta
dom <- c(0,1)
yylim <- c(0,2)
grid <- seq(from=dom[1], to=dom[2], by=0.01)
N <- 10 # number of grid points for the trapezoidal rule
NN <- seq(from=dom[1], to=dom[2], length=N+1)
delta <- diff(dom)/N
f <- function(x) {0.4 + (cos(5*x) + sin(2*x))^2}
op <- par(mfrow=c(2,1))
plot(grid, f(grid), type="l", col="black", 
  main=expression(paste(bold("Trapezoidal rule for "), italic(d), "=1")),
  ylim=yylim,
  xlab=expression(italic(x)), ylab=expression(paste(italic(f), group("(", italic(x),")"))))
legend("topleft", legend=c(expression(italic(f))), lty=c(1), bty='n') 
for (n in 2:(N+1)) {
  lines(c(NN[n-1],NN[n]),  c(f(NN[n-1]), f(NN[n])), type="l", col="red")
}
c <- 2
eps <- 0.01
d <- seq(from=1, to=5, by=1) # dimension of the domain
gridpoints <- round(exp(-d/c*log(eps)))
options(scipen=5)
plot(d, gridpoints, type="b", xlab=expression(paste("Dimension (", italic(d), ")")), 
     ylab=expression(paste("No. of grid points (", italic(N), ")")),
     main="Curse of dimensionality", col="red")
## EXAMPLE 1
## Numerical integration methods: illustration of the curse of dimensionality 
dom <- c(0,1)
yylim <- c(0,2)
grid <- seq(from=dom[1], to=dom[2], by=0.01)
N <- 10 # number of grid points for the trapezoidal rule
NN <- seq(from=dom[1], to=dom[2], length=N+1)
delta <- diff(dom)/N
f <- function(x) {0.4 + (cos(5*x) + sin(2*x))^2}
op <- par(mfrow=c(2,1))
plot(grid, f(grid), type="l", col="black", 
  main=expression(paste(bold("Trapezoidal rule for "), italic(d), "=1")),
  ylim=yylim,
  xlab=expression(italic(x)), ylab=expression(paste(italic(f), group("(", italic(x),")"))))
legend("topleft", legend=c(expression(italic(f))), lty=c(1), bty='n') 
lines(c(NN[1],NN[1]),  c(0, f(NN[1])), type="l", col="red")
for (n in 2:(N+1)) {
  lines(c(NN[n-1],NN[n]),  c(f(NN[n-1]), f(NN[n])), type="l", col="red")
  lines(c(NN[n],NN[n]),  c(0, f(NN[n])), type="l", col="red")
}
c <- 2
eps <- 0.01
d <- seq(from=1, to=5, by=1) # dimension of the domain
gridpoints <- round(exp(-d/c*log(eps)))
options(scipen=5)
plot(d, gridpoints, type="b", xlab=expression(paste("Dimension (", italic(d), ")")), 
     ylab=expression(paste("No. of grid points (", italic(N), ")")),
     main="Curse of dimensionality", col="red")
dom <- c(0,1)
yylim <- c(0,2)
grid <- seq(from=dom[1], to=dom[2], by=0.01)
N <- 10 # number of grid points for the trapezoidal rule
NN <- seq(from=dom[1], to=dom[2], length=N+1)
delta <- diff(dom)/N
f <- function(x) {0.4 + (cos(10*x) + sin(4*x))^2}
op <- par(mfrow=c(2,1))
plot(grid, f(grid), type="l", col="black", 
  main=expression(paste(bold("Trapezoidal rule for "), italic(d), "=1")),
  ylim=yylim,
  xlab=expression(italic(x)), ylab=expression(paste(italic(f), group("(", italic(x),")"))))
legend("topleft", legend=c(expression(italic(f))), lty=c(1), bty='n') 
lines(c(NN[1],NN[1]),  c(0, f(NN[1])), type="l", col="red")
for (n in 2:(N+1)) {
  lines(c(NN[n-1],NN[n]),  c(f(NN[n-1]), f(NN[n])), type="l", col="red")
  lines(c(NN[n],NN[n]),  c(0, f(NN[n])), type="l", col="red")
}
c <- 2
eps <- 0.01
d <- seq(from=1, to=5, by=1) # dimension of the domain
gridpoints <- round(exp(-d/c*log(eps)))
options(scipen=5)
plot(d, gridpoints, type="b", xlab=expression(paste("Dimension (", italic(d), ")")), 
     ylab=expression(paste("No. of grid points (", italic(N), ")")),
     main="Curse of dimensionality", col="red")
dom <- c(0,1)
yylim <- c(0,4)
grid <- seq(from=dom[1], to=dom[2], by=0.01)
N <- 10 # number of grid points for the trapezoidal rule
NN <- seq(from=dom[1], to=dom[2], length=N+1)
delta <- diff(dom)/N
f <- function(x) {0.4 + (cos(10*x) + sin(4*x))^2}
op <- par(mfrow=c(2,1))
plot(grid, f(grid), type="l", col="black", 
  main=expression(paste(bold("Trapezoidal rule for "), italic(d), "=1")),
  ylim=yylim,
  xlab=expression(italic(x)), ylab=expression(paste(italic(f), group("(", italic(x),")"))))
legend("topleft", legend=c(expression(italic(f))), lty=c(1), bty='n') 
lines(c(NN[1],NN[1]),  c(0, f(NN[1])), type="l", col="red")
for (n in 2:(N+1)) {
  lines(c(NN[n-1],NN[n]),  c(f(NN[n-1]), f(NN[n])), type="l", col="red")
  lines(c(NN[n],NN[n]),  c(0, f(NN[n])), type="l", col="red")
}
c <- 2
eps <- 0.01
d <- seq(from=1, to=5, by=1) # dimension of the domain
gridpoints <- round(exp(-d/c*log(eps)))
options(scipen=5)
plot(d, gridpoints, type="b", xlab=expression(paste("Dimension (", italic(d), ")")), 
     ylab=expression(paste("No. of grid points (", italic(N), ")")),
     main="Curse of dimensionality", col="red")
quit()
rm(list = ls())
set.seed(123)
pathToInputBase   <- "/home/axel/Dropbox/research/code/cpp/mc"
pathToOutputBase  <- "/home/axel/Dropbox/research/output/cpp/mc"
exampleName       <- "factorCopulaSv"
projectName       <- "copulaSv"
jobName           <- "debug"
source(file=file.path(pathToInputBase, "setupRCpp.r"))
## ========================================================================= ##
##
## MODEL
##
## ========================================================================= ##
## Selecting the model:
# Model to be estimated:
# 0: exactly measured log-volatility
# 1: noisily measured log-volatility
modelType <- 0
# Type of copulas used for modelling the dependence structure
# between the noise variables and the latent factors:
# 0: Gaussian
# 1: rotated by 90 degrees
# 2: rotated by 270 degrees
copulaTypeH  <- 0 # dependence between exchange-rate noise eta and latent factor H
copulaTypeZ  <- 0 # dependence between volatility noise zeta and latent factor Z
copulaTypeHZ <- 0 # dependence between latent factors H and Z
# Number of observed exchange rates:
nExchangeRates <- 3
# Number of observations:
nObservations  <- 65
smcParameters  <- c(3) # additional parameters to be passed to the particle filter;
# Here, the only element of smcParameters determines the number of lookahead steps 
# used if we employ the Kalman filtering/smoothing approximation-based 
# proposal kernel.
mcmcParameters <- numeric(0) # additional parameters to be passed to the MCMC (e.g. PMMH) updates
## Miscellaneous parameters:
MISC_PAR      <- list(pathToCovar=pathToCovar, pathToData=pathToData, pathToFigures=pathToFigures, pathToInputBase=pathToInputBase, pathToOutputBase=pathToOutputBase)
## Auxiliary (known) model parameters and data:
MODEL_PAR     <- getAuxiliaryModelParameters(modelType, copulaTypeH, copulaTypeZ, copulaTypeHZ, nExchangeRates, MISC_PAR)
## Auxiliary parameters for the SMC and MCMC algorithms:
ALGORITHM_PAR <- getAuxiliaryAlgorithmParameters(MODEL_PAR$dimTheta, MODEL_PAR$nObservations)
# If we measure the log-volatility exactly, the posterior distribution of the
# latent variables factorises into a product of the marginal posterior distributions
# for each time step. Therefore, to ensure that the estimator for the marginal likelihood
# factorises in the same way, we need to enforce resampling at every time step.
if (modelType == 0) {
  ALGORITHM_PAR$essResamplingThresholdLower <- 99
}
###############################################################################
##
## Approximating the Marginal (Count-Data) Likelihood
##
###############################################################################
nThetaValues <- 4
nSimulations <- 4
simulateData <- FALSE
if (simulateData == TRUE) {
  MODEL_PAR$nObservations <- nObservations
}
nParticlesLower <- c(100, 200, 300)
N_PARTICLES_LOWER <- nParticlesLower
MM <- nSimulations
KK <- nThetaValues
NN <- length(N_PARTICLES_LOWER)
logZ <- array(NA, c(KK, MM))
thetaInit <- c()
#   thetaTrue <- sampleFromPriorCpp(MODEL_PAR$dimTheta, MODEL_PAR$hyperParameters, MODEL_PAR$support, nCores); # making sure that all algorithms are initialised in the same way
  varthetaAux <- c(0, 1/2, 10, 1/100, 1/10, 1/2, 1/2)
  thetaTrue <- c(rep(varthetaAux, each=nExchangeRates), 1/2)
  
  parTrueAux <- simulateDataCpp(MODEL_PAR$nObservations, MODEL_PAR$hyperParameters, thetaTrue, nCores)
parTrueAux
parTrueAux$logExchangeRates
parTrueAux$logInitialExchangeRates
parTrueAux$initialLogExchangeRates
parTrueAux$initialLogVolatilities
parTrueAux$logVolatilities
nObservations
## Selecting the model:
# Model to be estimated:
# 0: exactly measured log-volatility
# 1: noisily measured log-volatility
modelType <- 0
# Type of copulas used for modelling the dependence structure
# between the noise variables and the latent factors:
# 0: Gaussian
# 1: rotated by 90 degrees
# 2: rotated by 270 degrees
copulaTypeH  <- 0 # dependence between exchange-rate noise eta and latent factor H
copulaTypeZ  <- 0 # dependence between volatility noise zeta and latent factor Z
copulaTypeHZ <- 0 # dependence between latent factors H and Z
# Number of observed exchange rates:
nExchangeRates <- 3
# Number of observations:
nObservations  <- 65
smcParameters  <- c(3) # additional parameters to be passed to the particle filter;
# Here, the only element of smcParameters determines the number of lookahead steps 
# used if we employ the Kalman filtering/smoothing approximation-based 
# proposal kernel.
mcmcParameters <- numeric(0) # additional parameters to be passed to the MCMC (e.g. PMMH) updates
## Miscellaneous parameters:
MISC_PAR      <- list(pathToCovar=pathToCovar, pathToData=pathToData, pathToFigures=pathToFigures, pathToInputBase=pathToInputBase, pathToOutputBase=pathToOutputBase)
## Auxiliary (known) model parameters and data:
MODEL_PAR     <- getAuxiliaryModelParameters(modelType, copulaTypeH, copulaTypeZ, copulaTypeHZ, nExchangeRates, MISC_PAR)
## Auxiliary parameters for the SMC and MCMC algorithms:
ALGORITHM_PAR <- getAuxiliaryAlgorithmParameters(MODEL_PAR$dimTheta, MODEL_PAR$nObservations)
# If we measure the log-volatility exactly, the posterior distribution of the
# latent variables factorises into a product of the marginal posterior distributions
# for each time step. Therefore, to ensure that the estimator for the marginal likelihood
# factorises in the same way, we need to enforce resampling at every time step.
if (modelType == 0) {
  ALGORITHM_PAR$essResamplingThresholdLower <- 99
}
MODEL_PAR$logExchangeRates
parTrueAux$latentTrue
MODEL_PAR$nObservations
# Number of observations:
nObservations  <- 65
smcParameters  <- c(3) # additional parameters to be passed to the particle filter;
# Here, the only element of smcParameters determines the number of lookahead steps 
# used if we employ the Kalman filtering/smoothing approximation-based 
# proposal kernel.
mcmcParameters <- numeric(0) # additional parameters to be passed to the MCMC (e.g. PMMH) updates
## Miscellaneous parameters:
MISC_PAR      <- list(pathToCovar=pathToCovar, pathToData=pathToData, pathToFigures=pathToFigures, pathToInputBase=pathToInputBase, pathToOutputBase=pathToOutputBase)
## Auxiliary (known) model parameters and data:
MODEL_PAR     <- getAuxiliaryModelParameters(modelType, copulaTypeH, copulaTypeZ, copulaTypeHZ, nExchangeRates, MISC_PAR)
## Auxiliary parameters for the SMC and MCMC algorithms:
ALGORITHM_PAR <- getAuxiliaryAlgorithmParameters(MODEL_PAR$dimTheta, MODEL_PAR$nObservations)
# If we measure the log-volatility exactly, the posterior distribution of the
# latent variables factorises into a product of the marginal posterior distributions
# for each time step. Therefore, to ensure that the estimator for the marginal likelihood
# factorises in the same way, we need to enforce resampling at every time step.
if (modelType == 0) {
  ALGORITHM_PAR$essResamplingThresholdLower <- 99
}
MODEL_PAR$nObservations
rm(list = ls())
set.seed(123)
pathToInputBase   <- "/home/axel/Dropbox/research/code/cpp/mc"
pathToOutputBase  <- "/home/axel/Dropbox/research/output/cpp/mc"
exampleName       <- "factorCopulaSv"
projectName       <- "copulaSv"
jobName           <- "debug"
source(file=file.path(pathToInputBase, "setupRCpp.r"))
## ========================================================================= ##
##
## MODEL
##
## ========================================================================= ##
## Selecting the model:
# Model to be estimated:
# 0: exactly measured log-volatility
# 1: noisily measured log-volatility
modelType <- 0
# Type of copulas used for modelling the dependence structure
# between the noise variables and the latent factors:
# 0: Gaussian
# 1: rotated by 90 degrees
# 2: rotated by 270 degrees
copulaTypeH  <- 0 # dependence between exchange-rate noise eta and latent factor H
copulaTypeZ  <- 0 # dependence between volatility noise zeta and latent factor Z
copulaTypeHZ <- 0 # dependence between latent factors H and Z
# Number of observed exchange rates:
nExchangeRates <- 3
# Number of observations:
nObservations  <- 65
smcParameters  <- c(3) # additional parameters to be passed to the particle filter;
# Here, the only element of smcParameters determines the number of lookahead steps 
# used if we employ the Kalman filtering/smoothing approximation-based 
# proposal kernel.
mcmcParameters <- numeric(0) # additional parameters to be passed to the MCMC (e.g. PMMH) updates
## Miscellaneous parameters:
MISC_PAR      <- list(pathToCovar=pathToCovar, pathToData=pathToData, pathToFigures=pathToFigures, pathToInputBase=pathToInputBase, pathToOutputBase=pathToOutputBase)
## Auxiliary (known) model parameters and data:
MODEL_PAR     <- getAuxiliaryModelParameters(modelType, copulaTypeH, copulaTypeZ, copulaTypeHZ, nExchangeRates, MISC_PAR)
## Auxiliary parameters for the SMC and MCMC algorithms:
ALGORITHM_PAR <- getAuxiliaryAlgorithmParameters(MODEL_PAR$dimTheta, MODEL_PAR$nObservations)
# If we measure the log-volatility exactly, the posterior distribution of the
# latent variables factorises into a product of the marginal posterior distributions
# for each time step. Therefore, to ensure that the estimator for the marginal likelihood
# factorises in the same way, we need to enforce resampling at every time step.
if (modelType == 0) {
  ALGORITHM_PAR$essResamplingThresholdLower <- 99
}
###############################################################################
##
## Approximating the Marginal (Count-Data) Likelihood
##
###############################################################################
nThetaValues <- 4
nSimulations <- 4
simulateData <- FALSE
if (simulateData == TRUE) {
  MODEL_PAR$nObservations <- nObservations
}
nParticlesLower <- c(100, 200, 300)
N_PARTICLES_LOWER <- nParticlesLower
MM <- nSimulations
KK <- nThetaValues
NN <- length(N_PARTICLES_LOWER)
logZ <- array(NA, c(KK, MM))
thetaInit <- c()
 thetaTrue <- sampleFromPriorCpp(MODEL_PAR$dimTheta, MODEL_PAR$hyperParameters, MODEL_PAR$support, nCores); # making sure that all algorithms are initialised in the same way
  varthetaAux <- c(0, 1/2, 10, 1/100, 1/10, 1/2, 1/2)
  thetaTrue <- c(rep(varthetaAux, each=nExchangeRates), 1/2)
  
  parTrueAux <- simulateDataCpp(MODEL_PAR$nObservations, MODEL_PAR$hyperParameters, thetaTrue, nCores)
parTrueAux$latentTrue
  if (simulateData) {
    print(count)
    MODEL_PAR$thetaTrue               <- thetaTrue
    MODEL_PAR$latentTrue              <- parTrueAux$latentTrue
    MODEL_PAR$logExchangeRates        <- parTrueAux$logExchangeRates
    MODEL_PAR$logVolatilities         <- parTrueAux$logVolatilities
    MODEL_PAR$initialLogExchangeRates <- parTrueAux$initialLogExchangeRates
    MODEL_PAR$initialLogVolatilities  <- parTrueAux$initialLogVolatilities
  }
  thetaInit <- cbind(thetaInit, thetaTrue)
kk <- 1
  for (mm in 1:MM) {
    for (nn in 1:NN) {
      print(paste("kk: ", kk, "nn: ", nn))
      aux <- runSmcFilterCpp(
          MODEL_PAR$logExchangeRates, MODEL_PAR$logVolatilities, MODEL_PAR$initialLogExchangeRates, MODEL_PAR$initialLogVolatilities, 
          MODEL_PAR$dimTheta, MODEL_PAR$hyperParameters, MODEL_PAR$support, N_PARTICLES_LOWER[nn], ALGORITHM_PAR$essResamplingThresholdLower, smcParameters, 
          thetaInit[,kk], 0, nCores 
        )
        
      logZ[kk,nn,mm] <- aux$logLikelihoodEstimate
    }
  }
